---
layout: post
title: 그림으로 이해하는 마이크로서비스 구조
description: >
  **디지털 전환(DX) 실현을 위한 기초 기술 ‘마이크로서비스’의 핵심을 쉽고 빠르게 습득하자!**
  이제는 마이크로서비스 방식으로 애플리케이션을 개발하고, 그 애플리케이션을 컨테이너에 배포해서 실행하며, 오케스트레이션 기능을 통해 컨테이너화된 애플리케이션을 운영한다. 이 책은 바로 이 마이크로서비스가 무엇인지, 애자일이 무엇인지, 클라우드가 무엇인지, 그리고 디지털 혁신이 무엇인지 등 마이크로서비스와 관련된 기술 요소를 폭넓게 다루면서 그 핵심을 한눈에 볼 수 있도록 그림과 함께 쉽게 설명한다.

tags: [book]
author: author2
canonical_url: https://jpub.tistory.com
---

[그림으로 이해하는 마이크로서비스 구조] (사진)
[그림으로 이해하는 마이크로서비스 구조] (출판사 책 설명 링크)

# 제 1 장 디지털 전환: 마이크로서비스가 중요해진 배경
## 1.1. 디지털 전환이란
- DX의 본질
- 사람이 수작업으로 하던 프로세스를 디지털화된 프로세스로 변경, 즉 디지털 기술로 전환/적용하는 것
- 디지털 전환을 통해 새로운 혁신을 만들어 내는 것
- 단순 디지털로 전환이 아닌 비즈니스를 근본적으로 바꾸는 것

## 1.2. 2025년의 벽
- DX를 소홀히 해서 2025년 이후 큰 경제적 손실 예상 == 2025년의 벽
- DX 인재 부족 → 기술, 투자, 비즈니스 전반에 악영향 → 경제적 손실
- 비즈니스 경쟁력 저하의 원인 : 인재 부족, 기술 부채
- 해결방안
  - 인프라 표준화 : 컨테이너 가상화 (k8s)
  - Application 현대화 (microservices)
  - IT개발/운영 내재화를 통한 DevOps

## 1.3. DX 추진을 위한 방침
- 앞에 좋은 얘기 + <span style="color:orange">빠른 시장 변화에 대응할 수 있도록 조직 구성, Agile한 의사결정/문화<span>

# 제 2 장 클라우드 네이티브 컴퓨팅과 마이크로서비스
## 2.1. 클라우드 컴퓨팅 발자취
- REST
  - 클라우드 서비스 모델: On-Premise → Cloud (IaaS, PaaS, SaaS)
  - + CI/CD, DevOps, Agile, … → Microservices

## 2.2. 클라우드 네이티브 컴퓨팅
- Cloud Native
  CNCF(Cloud Native Computing Foundation)라는 단체에서 정의하고 있음, 국제 표준 뭐 그런건 아님
- 목적: 확장 가능한 애플리케이션을 구축/운영하는 것과 IT시스템에 최소한의 인력으로 자주, 계획한 만큼 임팩트가 있는 변경을 추가하는 것
- → 비즈니스의 변화에 따른 시스템의 개선 요구를 쉽고 빠르게 적용/배포 할 수 있는 유연한 컴퓨팅 시스템
- 구성: Container, Continuous Integration , Microservices, DevOps + <span style="color:orange">Agile (개인적으로 추가)<span>
- Cloud Native Landscape : [Go](https://landscape.cncf.io){:target="_blank"}

## 2.3. 클라우드 네이티브 컴퓨팅을 지탱하는 기술 요소
- Cloud Native Trail Map : Cloud Native Computing 로드맵
- 어떻게 도입할지, 어디서부터 시작할지 등 참고할 수 있음
- Container : 서버 가상화
- Linux Kernel 기능을 이용해서 OS수준의 가상환경 실현, OS 공유 + Container에는 앱 실행을 위한 Lib 까지만 포함
- Hypervisor: Hardware 수준의 가상화 (하나의 H/W에 여러개의 가상 환경 호스팅, 각각 OS 만들어서 사용)
- Container Orchestration
- 가용성/확장성 위해 클러스터, 컨테이터 구축 많이 함 → Container 많아짐 → 많아진 Container의 구성/관리 필요
  - → Kubernetes가 가장 많이 사용, 거의 표준에 가까움 (Google이 만들어서 공유)
- DevOps
  - 기획 → 설계/개발 → 통합/테스트 → 배포 → 피드백 → 기획 → … 같이 피드백의 빠른 반영해서 비즈니스의 목표 달성, 성과 최대화
  - 정리하면, 애자일 개발 프로세스나 CD등의 기존 기법, 기술과 연계해 IT 시스템 개발/릴리스 속도 향상과 유연한 변경을 애플리케이션 개발/운영의 효율화라는 관점에서 실현하게 해주는 것
- Cloud Native Computing을 진행하는 이유 → DevOps/k8s 관점에서만 설명하는 듯
- IT 시스템 개발/운영 속도 향상 및 품질 향상 → CI/CD 자동화
- 확장성(scalability), 고가용성(high availability) → Kubernetes(쉽게 구성하고 관리 가능)
- 비용 절감 → Kubernetes(multi-platform 구성)

- <span style="color:orange">이 책은 DevOps/k8s 관점에서만 설명하고 있음<span>
  - <span style="color:orange">이 기술 요소를 실제 수행 팀의 DT기술 역량, Agile에 기반한 사업수행역량 확보가 동반되어야 함<span>
  - <span style="color:orange">특히 Cloud Infra, Platform에 최적화된(현대화된) Application의 개발 역량이 중요함<span>
  - <span style="color:orange">또한, 위의 기술요소 적용 수준을 판단하는 Assessment 개발/적용해서, 완료 후 수준에 따른 결과를 확인해서 지속적인 개선도 되어야 함<span>

## 2.4. 마이크로서비스란?
- 정의: Cloud에 최적화된 Application
- 마이크로서비스 아키텍처
  - 독립성, 응집성을 갖는 소프트웨어 컴포넌트(서비스)를 여러개 조합해서 하나의 시스템을 구축하는 소프트웨어의 형태
- 마이크로서비스 아키텍처 스타일
  - 인프라/실행 환경: PaaS, Container
  - 개발/운영 기법: DevOps, Agile Development Process, DDD, SRE
  - 개발/운영 환경: CI/CD
  - 애플리케이션 통합: REST, Messaging, API, Eventual Consistency
- 장단점

    |장점|단점|
    |---|---|
    |<li>빠르고 유연한 애플리케이션 변경</li><li>작은 서비스 단위의 확장</li><li>장애 격리, 빠른 복구</li>|<li>빈번한 통신, 통신 지연</li><li>분산된 데이터의 동기화, 정합성 이슈</li><li>모니터링</li><li>Tracing 어려움</li><li>Learning Curve(<span style="color:orange">프로젝트에서는 이 부분이 제일 문제임<span>)</li>|
- 단점이 커도 사용하는 이유?
  - 빠르고 유연한 애플리케이션 변경 → 시장 변화에 빠른 대응, 선점 == Business Agility

## 2.5. 마이크로서비스 특징
- 서비스를 사용한 컴포넌트 설계: 작은 단위로 개발, 가벼운 통신 프로토콜을 사용한 연계
- 비즈니스 기능을 기준으로 한 팀 구성: Cross-Functional Team, Conway’s Law
- 프로젝트가 아닌 제품을 파악해서 개발/운영: **최종 사용자의 피드백을 반영**, 조금씩 적시에 릴리즈 하는 방식
- 지능적인 엔드포인트와 단순한 파이프
- 비중앙집권적인 개발 언어, 도구 선택: Polyglot, 서비스 별 최적의 개발언어, DB, 설계패턴 등 알아서 선정
- 단점: 개발팀 → 운영팀 으로 이관되는 경우 다양한 기술 사용에 따른 유지보수 난이도 높아짐
- 비중양집권적인 데이터 관리
- 인프라 자동화: 실현하기 위한 자동화된 CI/CD
- 장애/오류 발생을 전제로 한 설계
- 선진적인 설계: **이해관계자 전체가 참여해서 소통 기반의 경량화된 설계 방식을 의미**

## 2.6. 마이크로서비스의 개발/운영 흐름: Agile

## 2.7. 마이크로서비스의 적용 기준
- 장점, 단점을 비교해서 단점을 상쇄할 만한 가치가 있으면 적용, 아니면 적용하지 않는게 좋음
- 소형 시스템, 비교적 간단한 시스템은 연습용 정도로, 실제라면 의미 없음
- <span style="color:orange">이게 매우 중요함<span>
  - 작음 프로젝트는 그냥 하면 됨, 방법론, 애자일 뭐 이런거 다 필요 없음
  - 큰 도메인을 작게 나누고 그 각각을 해결하는 방식, 대형 사업에 적합하다고 할 수 있음


# 제 3 장 마이크로서비스 아키텍처의 기본
## 3.1. 서비스 구조
- CBD(Component Based Development), SOA(Service Oriented Architecture)와 유사
  - 인터페이스 : 애플리케이션에 입/출력 인터페이스
  - 서비스 : 구현해야 할 비즈니스 요건 (인터페이스와 모델을 포함)
  - 모델 : 비즈니스 데이터(?)
## 3.2. 레이어드 아키텍처 (Layred Architecture)
- 애플리케이션 내부에 계층을 만들고, 그 계층에 따라 컴포넌트나 기능을 분류, 관리하는 접근법
- 4계층
  |계층|주요 기능|
  |---|---|
  |사용자 인터페이스 계층|요청접수, 응답전송|
  |애플리케이션 계층|트렌잭션 관리, 도메인 객체 접근|
  |도메인 계층|도메인 상태와 동작 (기능 구현 영역)|
  |인프라 계층|데이터 / 메시지 접근 등 외부 시스템 연동|
### 3.2.1. 제어 반전 == 의존관계 역전 원칙
- 인접한 계층에만 접근해야 한다, 도메인 계층이 인프라 계층에 의존한다.
- 변화가 적은 계층으로 의존관계를 갖는 것이 유리하다.
## 3.3. 헥사고날 아키텍처
- 변경 가능성이 높은 기술 영역과 기능을 구현한 도메인 영역을 분리, 기술과 도메인 영역은 포트-아답터 패턴으로 연결
- 도메인 변경 시 기술 변경 고려 없이, 기술 변경시 도메인 변경없이 수행 가능
## 3.4. 데이터베이스 접근
- 마이크로서비스는 서비스 별 데이터베이스를 갖는 것이 좋다
## 3.5. 트랜젝션 처리
- 각 서비스 별 데이터베이스 단위로 Begin-Commit 하는 로컬 트랜잭션이 기본
## 3.6. 데이터베이스 간 동기화
- 서비스 별 분리된 데이터베이스는 데이터베이스의 동기화, 데이터 정합성을 맞춰야 한다.
- SAGA
  - Orchestrator Based SAGA : 
  - Choreography Based SAGA : 
## 3.7. 데이터 결합
- API Composition
  - 복수의 DB에서 얻은 데이터를 애플리케이션 계층에서 인메모리로 결합
  - 구현이 간단하지만, 메모리 증가 이슈로 성능 이슈 및 확장성 이슈 있음
  - Fronted, Backend 잘 분리하고 중간에 단일 통합지점이 생기는건 이상함
→ BFF나 Frontend에서 통합하는게 더 좋은 경우가 많을 듯
### 3.7.1. CQRS (Command Query Responsibility Segregation)
- CUD와 R의 분리 → 각각 DB 분리
  - CUD는 요청량이 적지만 확실한 트랜잭션 완료 요구 → ERD 
  - R은 요청량도 많고 빠른 처리 요구 → NoSQL DB 등 고성능 DB
### 3.7.2. Event Sourcing
- CUD용 저장소와 R용 저장소 동기화
 
### 3.7.3. CQRS & Event Sourcing의 장단점
  |장점|단점|
  |---|---|
  |<li>Query 구현의 용이성, 데이터 감시, 접근 제어 구현의 용이성</li><li>서비스 모델링과 친화성이 높음</li>|<li>기존 설계 방식과 다르고 어려움</li><li>적용에 적합한지 판단 잘해야 함</li>|

 →  CQRS, Event Sourcing은 안해본 방식, 어렵다, API Composition이 잘 안맞으면 그 대안책으로 선택하는 것이 좋다.
## 3.8. 서비스 간 연계
  ||REST|Messaging|
  |---|---|---|
  |방식|동기|비동기|
  |적용|쉬움|어려움, <span style="color:orange">안해본 방식<span>
  |단점|<li>처리시간이 걸리는 경우 지연 발생 가능</li><li>요청이 쌓이면 리소스 고갈로 장애 발생 가능</li>|<li>Trouble Shooting, Tracing 어려움</li>|

## 3.9. 서비스화 진행 방법, 팁
### 3.9.1. 애자일 개발, 원 팀, 도메인 주도 설계
- 애자일 개발
- 원 팀 (Cross Functional Team)
- 도메인 주도 설계

<span style="color:orange">마이크로서비스를 하기 위해서 위의 방법들이 필요하다.</br>
→ 고객의 요구에 맞는 Right Product를 만들기 위해 MSA가 채택되어야 하고, 또 위의 기법들이 필요하다.</span>

### 3.9.2. 서비스 화는 크게 시작해서 필요에 따라 세분화
- Monolith First, 서비스는 일단 크게 만들고 스프린트에서 작은 서비스로 분할한다.
- 일단 크게, 스프린트에서 작게.. 자체가 매우 모호한 표현임
- 쉽고 빠르게 접근할 수 있는 기법/방법이 필요함
- AS-IS 시스템이 있는 경우 Strangler Pattern, 점진적으로 분래해 나가는 방법이 있음
### 3.9.3. 세션 정보 유지
- 애플리케이션을 Stateless 로 설계/구현해야 가용성/확장성 높아짐
- 그러나, 세션을 유지해야 하는 경우가 있음
  - 세션 영구화 : 처리중이 상태를 DB 등 영구적인 데이터 저장소에 저장
  - Sticky Session : 상태가 저장되어 있는 서버에 클라이언트 요청을 전송하는 것
  - 상태의 서비스 화 : 상태를 유지하기 위한 서비스를 신설, 스테이트 자체는 DB같은 영구 저장소에 저장
### 3.9.4. 마이그레이션 기간 중의 의존관계
- 신규 서비스가 기존 Monolith 시스템에 의존하지 않도록 해야 함
- 반대는 가능, 어짜피 기존 시스템은 없어지니까.

# 제 4 장 마이크로서비스 패턴
- 디자인 패턴: 과거 반복을 통해 효율적인고 실패할 가능성이 적은 비법, 방법을 정리해서 정형화 한 것
- 마이크로서비스 패턴:  마이크로서비스를 활용한 클라우드 네이티브 시스템의 설계, 개발, 운영에 도움이 되는 기법이나 노하우를 재사용하기 쉽도록 추상화, 범용화 한 것
## 4.1. 마이크로서비스 패턴 (Chris Richardson’s www.microservices.io )
**Richardson의 마이크로서비스 패턴**
  |종류|패턴|
  |---|---|
  |애플리케이션 아키텍처 패턴</br>(Application Architecture Patten)|<li>모놀리스 아키텍처 (Monolith Architecture)</li><li>마이크로서비스 아키텍처 (Microservice Architecture)</li>
  |분해</br>(Decomposition)|<li>업무 기능별 분해 (by Business Capability)</li><li>세부 업무별 분해 (by Subdomain)</li><li>자립 서비스 (Self-Contained Service)</li><li>팀별 서비스 (Service per Team)</li>|
  |리펙터링</br>(Refactoring to Microservices)|<li>스트랭클러 애플리케이션 (Strangler Application)</li><li>부폐방지계층 (Anti-Corruption Layer)
  |데이터 관리</br>(Data Management)|<li>서비스 별 데이터베이스 (Database per Service)</li><li>공유 데이터베이스 (Shared Database)</li><li>사가 (SAGA)</li><li>API 컴포지션 (API Composition)</li><li>CQRS (Command Query Responsibility Segregation)</li><li>도메인 이벤트 (Domain Event)</li><li>이벤트 소싱 (Event Sourcing)</li>|
  |트랜잭션 메시징</br>(Transactional Messaging)|<li>트랜젝셔널 아웃박스 (Transactional Outbox)</li><li>>트랜잭셔널 로그 테일링 (Transactional Log Tailing)</li><li>>폴링 퍼블리셔 (Polling Publisher)|
  |...|...|
 
…
 
 
## 4.2. 데이터 관리 패턴
### 4.2.1. 데이터 관리 패턴의 배경과 동기
> 마이크로서비스는 도메인 모델에 근거해 업무 데이터를 분석하고, 서비스와 데이터베이스가 1:1 관계가 되도록 모델링 하는 것
- 데이터 관리에 있어 해결해야 할 과제 3가지
  - 데이터 동기화: 분산 데이터베이스 간 데이터 동기화는 어떻게 구현할 것인가?
  - 데이터베이스 배치 모델: 어떤 기준에 근거해서 데이터베이스를 배치할 것인가?
  - 데이터 결합: 분산 데이터베이스에 흩어져 있는 데이터를 어떻게 집약할 것인가?
### 4.2.2. 데이터베이스 배치 패턴의 예
#### [ 서비스 별 데이터베이스 (Service per Database) ]
> 각 마이크로서비스는 약한 결합(Loose Coupling)으로 각 서비스를 신속/유연하게 변경 가능함, </br>따라서 데이터베이스 설계 요구에 유연한 대응을 위해 서비스와 데이터베이스가 1:1 되도록 권장

  |장점|단점|
  |---|---|
  |<li>유연하고 빠른 애플리케이션 변경</li><li>요건에 맞는 최적의 데이터베이스 및 기술 선택 </br>→ 운영 어려움|<li>결과적 일관성 (근 실시간 데이터 동기화)</li><li>여러 데이터베이스 간 데이터 동기화 구조</br>(2 Phase Commit 사용 못함)</li><li>여러 데이터베이스에 걸쳐 있는 데이터를 검색 및 집약하는 구조</br>→ 성능 이슈 발생 가능</li>|

#### [ 공유 데이터베이스 (Shared Database) ]
> 결과적 일관성이 허용되지 않는 경우, 일관성 확보가 필요한 경우 데이터베이스 분산 안하고 하나의 데이터베이스를 공유

  |장점|단점|
  |---|---|
|<li>업무 데이터의 일관성을 쉽게 확보할 수 있음</li><li>기존 시스템과 데이터베이스 공동 이용이 용이</li>|<li>애플리케이션과 데이터베이스를 신속하고 유연하게 변경하는 것이 어려움</li><li>성능</li><li>단일 데이터베이스에 처리가 집중</li><li>비관적 락에 의한 순차적 처리 발생</li><li>확장성<li>데이터가 증가한 경우에는 데이터베이스 서버를 스케일업해서 대응해야함</li></li>
### 4.2.3. 데이터베이스 동기화 패턴의 예
- 분산 데이터베이스는 데이터 동기화, 즉 정합성 확보를 위해 SAGA를 권장
- SAGA: 로컬 트랜잭션의 이벤트와 보상 트랜잭션을 활용하는 디자인 패턴
  - 분산 환경에서는 Transaction 관리를 Application이 수행, 즉 Transaction의 주체가 DB가 아님
  - MSA에서 분산된 Application 하위의 DB는 Local Transaction처리만 담당
  - 만약 각 Application의 연속적인 Transaction 처리가 실패할 경우 Rollback처리를 Application이 수행, Atomicity를 보장해 주지는 못하지만 Eventual Consistency(결과적 일관성)은 보장함
- 종류 : 코레오그래피, 오케스트레이션
#### [ 코레오그래피 사가 패턴 ]
- 메시징 시스템
- 서비스 내부에 서비스 간 연계 흐름 제어 로직을 포함-관심사의 분리 X
- 전체 사가 파악 어려움, 트랜잭션 실행 시 진행 상태 확인이나 추적(Tracing)이 어려움
#### [ 오케스트레이션 사가 패턴 ]
- 사가 오케스트레이터가 트랜잭션 처리 조율-애플리케이션 계층에 배치되는 애플리케잇현 서비스로 구현됨
- 사가 오케스트레이터가 요청/응답 형식의 비동기 메시지를 통해 비즈니스 로직을 담당하는 도메인 계층 서비스에게 데이터 처리를 요청
- 장애 시 사가 오케이스트레이터가  오류를 감지해서 각 서비스에 보상 트랜잭션 실행을 의뢰
- 오케스트레이터가 사가 제어 로직 담당, 도메인 계층 서비스는 비즈니스 로직과 데이터 처리를 담당-역할을 명확하게 분리
- 서비스와 데이터베이스 간 연계 흐름 파악이 쉬움
## 4.3. 트랜잭셔널 메시징 패턴
### 4.3.1. 트랜잭션 메시징 패턴의 배경과 동기
- 사가: 데이터베이스에 처리를 적용함과 동시에 해당 처리가 완료됐다는 것을 이벤트로 통지해야 함
- 글로벌 트랜잭션: 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 방식
  - 하나의 트랜잭션에 여러개의 데이터베이스에 접근해 데이터를 처리해야하는 경우
  - 데이터베이스 처리 후 이벤트를 통지하는 작업을 하나의 트랜잭션으로 묶어야 하는 경우
### 4.3.2. 트랜잭션 메시징 패턴의 예
#### [ 트랜잭셔널 아웃박스 ]
- 트랜잭션 아웃박스는 데이터베이스 테이블로, 비즈니스 데이터를 저장하는 데이터베이스와 함께 저장
- 즉, 메시지 큐로 DB의 Table을 활용하는 패턴
  - 메시지 브로커에 메시지를 바로 발행하지 않고, 아웃박스라는 임시 데이터베이스 테이블에 메시지를 저장
  - 저장된 메시지는 Message Relay가 아웃박스 테이블의 메시지를 읽어 메시지 브로커로 발생한다. (약간의 시차가 발생하지만 Eventual Consistency 보장)

- 따라서 로컬 트랜잭션으로 동기화 가능
< 정상 처리 프로세스 >

정상 처리 프로세스
< 오류 발생 시 프로세스 >

오류 발생 시 프로세스
아웃박스 내 메시지 취득 방법에 따라 “폴링 퍼블리셔”, “트랜잭션 로그 테일링”의 2개 디자인이 있음
[ 폴링 퍼블리셔 ]
 
[ 트랜잭션 로그 테일링 ]
트랜잭셔널 메시징의 시작을 DBMS의 트랜잭션 로그의 로그 엔트리를 활용하는 패턴
트랜잭션 발생시 로컬 트랜잭션을 활용해서 업무 테이블 갱신과 동시에 처리 내용을 DBMS가 관리하는 로그에 기록
트랜잭션 로그 마이너라는 메시지 릴레이를 사용해서 DBMS 트랜잭션 로그상에 기록된 로그 엔트리를 취득
트랜잭션 로그 마이너는 새롭게 취득한 로그 엔트리를 MOM에 발생해서 후속 서비스의 트랜잭션에 연결

트랜잭션 로그 테일링 프로세스
DBMS가 제공하는 트랜잭션 로그를 사용하므로 아웃박스 테이블의 유지/관리 필요 없음
단, DBMS마다 트랜잭션 로그의 사양이 다르므로, DBMS 단위로 트랜잭션 로그 마이너를 구현해야 한다. 이 부분이 Application 개발이나 유지/보수에 부담이 될 수 있음 
## 4.4. 서비스 검색 패턴 (Service Discovery Pattern)
### 4.4.1. 서비스 검색 패턴의 배경과 동기
MSA 같은 분산 호나경은 서비스 간 원격 호울로 구성됨
Cloud 환경에서는 서비스가 Auto-Scaling 등에 의해 동적으로 생성되거나 Container 기반의 배포로 인해 서비스의 IP가 변경 발생
Clent가 서비스를 호출할때 IP주소를 알아내는 DNS(Domain Name Service)랑 비슷한게 필요함
== Service Discovery 
### 4.4.2. 서비스 검색 패턴의 예
Client-Side Discovery
Server-Side Discovery


Client가 Service Registry 검색해서 서비스 위치 확인
Client가 Server측 서비스 위치 찾기를 컴포넌트에 위임
부하분산기/프록시 등 서버측 경계에 있는 컴포넌트(라우터)
### 4.4.3. 서비스 레지스트리 패턴 (Service Registry Pattern)
Service Registry: Microservice의 서비스 명을 해석하는 컴포넌트
동작 방식
각 서비스의 인스턴스는 생성될때 자신의 주소(IP, Port)를 Service Registry (서비스 등록 서버)에 등록하고, 서비스가 종료될때 등록했던 주소 정보를 삭제
### 4.4.4. 서비스 레지스트리 등록 패턴의 예
[자가 등록]
서비스의 인스턴스가 생성될때 자신이 직접 도메인 명과 주소정보를 매핑해서 위치정보를 구성하고 이를 Service Registry에 등록
애플리케이션이 로직으로 등록 처리를 구현하기 때문에 요건 대응이 쉽고, 직관적임
서비스의 Health Check, 장애 발생시 복구 처리 직접 구현해야 하므로 공수 늘고, 로직이 복잡해짐
(로직에 비즈니스 기능과 Service Registry 등록/모니터링/복구 기능이 섞임)
[외부자 등록]
Service Registry에 등록을 애플리케이션 외에 위임: k8s
## 4.5. 외부 API 패턴
다양한 클라이언트와 연동하기 위한 패턴
### 4.5.1. 외부 API 패턴의 배경과 동기
외부에서 접속할때 발생하는 문제점
|문제점|대책|
|---|---
|서로 다른 통신 프로토콜 간 통신 해결|인터넷과 인트라넷 간 통신 프로토콜 해결|
|네트워크 지연 경험|클라이언트와 서비스간 통신 빈도의 최소화|
|클라이언트 프로그램의 복잡성 방지|서비스 호출 처리 코드 최소화|	
|유연하고 빠른 써비스 구현 변경 확보|서비스 변경에 따른 클라이언트 영향 최소화|
|다양한 클라이언트 종류 지원|클라이언트 별 게이트웨이 처리 효율화|

- 통신 프로토콜 교환 및 교차
- 네트워크 지연: 하나의 요청을 여러번 서비스 호출로 처리해야 하는 경우 클라이언트-서비스 간 통신 횟수 최소화 → 네트워크 지연 방지
- 클라이언트 프로그램 코드: 코드양 최소화 위해 서비스 호출 횟수 줄이기
  - 서비스 변경이 클라이언트 프로그램에 영향을 주지 않도록 하는 장치 마련
  - 다양한 클라이언트를 지원하기 위한 구조 고려
### 4.5.2. 외부 API 패턴
[API 게이트웨이]
- API 게이트웨이 패턴: 도메인의 경계에 클라이언트 처리를 담당하는 전용 서비스(API 게이트웨이)를 설치하는 패턴
[BFF, Backend For Frontend]
- 다양한 클라이언트 종류에 대응, 클라이언트 유형별로 API 게이트웨이를 별도로 구성하는 외부 API 패턴
> 정리하면, 
> - API 게이트웨이 제품은 인증 및 허가, 로그, 메트릭, 부하분산 등 범용적인 관리 용도로 사용한다.  
> - API 게이트웨이 패턴은 애플리케이션 조율을 책임진다. 
> - BFF 패턴은 클라이언트별로 게이트웨이 처리를 적용한다.   
## 4.6 통신 패턴
### 4.6.1. 통신 패턴의 배경과 동기
- 다양한 프로토콜을 적재적소에 활용할 수 있어야 함
- 동기/비동기 통신 상태 필요
- 멱등성 필요
> 멱등성이란?
>
>
### 4.6.2. 통신 패턴의 예
[원격 프로시저 호출, RPI, Remote Procedure Invocation]
- REST: 쉽고 간단, 범용적, but 동기방식으로 확장성 부족, 복잡하고 오러걸리는 처리에 부적합
[메시징]
- 비동기: Publisher-Subscriber, Producer-Consumer
[도메인 특화 프로토콜]
- 특정 상황에 맞는 고유의 프로토콜을 적용하는 방식
  - 메일발송-SMTP
  - 메일수신-POP/IMAP
[멱등 소비자]
- 실행 횟수에 상관없이 결과가 같다는 것을 보장, 중복 실행 방지

< SAGA, Transactional Output Pattern의 예 >
|순서|주문 서비스|재고 서비스|
|---|---|---|
|1|주문 완료 이벤트 발신|| 
|2||주문 완료 이벤트 수신|
|3||수신한 이벤트의 ID가 아웃박스 테이블에 있는지 확인|
|4||<li>있으면: pass</li><li>없으면: 재고 테이블에 재고 할당, 아웃박스 테이블에 주문ID 기록</li>|
## 4.7. 배포 패턴
### 4.7.1. 배포 패턴의 배경과 동기
- 배포 = 배포 프로세스 + 배포 아키텍처
- 기존 모놀리스 애플리케이션은 인프라팀에서 배포 수행<br>→ CI/CD 도입해서 빌드/배포 자동화 처리<br>: DevOps 방식으로 개발팀과 운영팀이 긴밀하게 협조해서 신속/지속적으로 서비스 제공 가능
<배포 아키텍처의 발전 이미지>
[배포 패턴의 필요성]
- 분산 애플리케이션: 마이크로서비스 실현
- 확장성: 리소스, 마이크로서비스 별 가동률 최적화, 확장성 확보
- 유지/보수:  대규모 마이크로서비스에서 운영 리소스의 최적화 위해 ← 마이크로서비스의 장점을 적은 듯
- 최신 기술 도입: 신기숙 도입, 릴리즈 주기를 빠르게 가져가기 위해
### 4.7.2. 배포 패턴의 예
[호스트 별 다중 서비스 인스턴스]
- 한 대의 호스트에 여러개의 서비스를 실행하는 형태

  |장점|단점|
  |---|---|
  |<li>호스트 관리 용이</li><li>가상화 환경인 경우, 하나의 호스트를 사용하므로 인프라 비용을 줄일 수 있음</li>|<li>모니터링, 장애 관리(트래킹) 어려움</li><li>호스트의 CPU 사용률을 감시해도 개별 서비스의 CPU 사용율을 파악할 수 없음</li><li>특정 서비스에 부하가 걸린 경우, 다른 서비스가 사용할 수 있는 리소스가 줄어들어 성능에 영향 발생 가능</li><li>호스트에 장애 발생이 호스트 내 전체 서비스에 장애임</li><li>호스트 내 서비스가 의존관계가 있는 경우, 배포, 확장성 설계가 복잡해짐</li>|

[호스트 별 단일 서비스 인스턴스]
- 한 대의 호스트에 하나의 서비스만 실행하는 형태
이미지
  |장점|단점|
  |---|---|
  |“호스트 별 다중 서비스 인스턴스”의 단점 다 해소|호스트 수 증가로 인프라 비용 증가|

[VM 별 서비스 인스턴스]
- 배포 대상을 하이퍼바이저 형 가상 머신을 사용하는 패턴
- 가상 머신은 배포 대상 옵션으로 무겁고 배포에 긴 시간이 걸려 컨테이너보다 많은 리소스를 사용함
- CSP에서 제공하는 배포 파이프라인을 통해 필요한 소프트웨어가 패키지화 된 가상 머신 이미지를 서비스 인스턴스트로 제공 → 서비스 수가 적은 경우 컨테이너 형 가상화보다 적은 비용으로 배포 할 수도 있음